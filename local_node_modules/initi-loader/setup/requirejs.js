import fs from "fs";
import vm from "vm";
import requirejs from "requirejs";

/**
 * Monkey-patch requirejs for Node.js to make modules with `(this)` inside strict mode
 * work correctly â€” `this` will be equal to `globalThis`.
 */
function patchRequirejsForNode(verbose = false) {
    patchOriginalDefine();

    const sandbox = Object.assign(global.window, {
        process,
        exports: {},
        module: { exports: {} },
        global: global,
        globalThis: global,
        v2: Object.create(null),
        std: Object.create(null),
        define: requirejs.define,
        require: requirejs,
        requirejs,
    });
    vm.createContext(sandbox);

    requirejs.load = function (context, moduleName, url) {
        if (sandbox.loader == undefined && global.loader != undefined) {
            sandbox.loader = global.loader;
        }

        const fullPath = requirejs.toUrl(url);
        if (verbose) {
            console.log(`[requirejs.load] loading ${moduleName} from ${fullPath}`);
        }

        let code;
        try {
            code = fs.readFileSync(fullPath, "utf8");
            if (fullPath.includes("webgl-debug.js")) {
                code = wrapWebGlDebugModule(code);
            } 
        } catch (err) {
            context.onError({
                requireModules: [moduleName],
                src: fullPath,
                originalError: err,
            });
            return;
        }

        try {
            const patchedCode = replaceContent(code);
            const script = new vm.Script(patchedCode, { filename: fullPath });
            script.runInContext(sandbox);
            context.completeLoad(moduleName);
            updateGlobalThisFromSandbox(sandbox);
            
            if (verbose) {
                console.log(`[requirejs.load] executed ${moduleName}`);
            }
        } catch (err) {
            console.error(`[requirejs.load] ERROR in ${moduleName}:`, err);
            context.onError({
                requireModules: [moduleName],
                src: fullPath,
                originalError: err,
            });
        }
    };
}

function patchOriginalDefine() {
    const originalDefine = requirejs.define;
    requirejs.define = function (moduleName, deps, factory) {
        if (Array.isArray(deps)) {
            deps = deps.filter(depName => !depName.includes("css!"));
        }
        originalDefine(moduleName, deps, factory);
    };
    requirejs.define.amd = originalDefine.amd;
}

function wrapWebGlDebugModule(originalSource) {
    const wrappedSource = `
(function (_export) {
    ${originalSource}
    _export.WebGLDebugUtils = WebGLDebugUtils;
})(this);
`
    return wrappedSource;
}

function replaceContent(code) {
    const nodejsCheck = "typeof module";
    // Deleting `use strict` to prevent `this` from being `undefined` in strict mode
    let patchedCode = code.replace(/^\s*(['"])use strict\1\s*;?\s*(?:\r?\n)?/gm, "");
    if (patchedCode.includes(nodejsCheck)) {
        // Patch base64js.min code to not use `exports` and `module`
        patchedCode = patchedCode.replace(nodejsCheck, "'undefined'");
    }
    return patchedCode;
}

function updateGlobalThisFromSandbox(sandbox) {
    globalThis.v2 = sandbox.v2;
    globalThis.std = sandbox.std;
    globalThis.ui = sandbox.ui;
    globalThis.i18n = sandbox.i18n;
}

export default function initRequirejs(options) {
    patchRequirejsForNode();
    global.requirejs = requirejs;
    return requirejs;
}
